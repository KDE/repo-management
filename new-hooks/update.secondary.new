#!/usr/bin/perl -w
use warnings;

###############
### Update hook startup
###############

# Retrieve the repo-management directory path....
# This is done in a begin block in order to be ready for it to be used by "use lib" below
BEGIN {
    $repomgmt_dir = $ENV{'HOME'} . "/repo-management";
    $repomgmt_dir = $ENV{'REPOMGMT_DIR'} if( $ENV{'REPOMGMT_DIR'} );
}

# Put an Axe into @INC so we can call "use", and have everything imported....
use lib "$repomgmt_dir/new-hooks/";
use GitHookLib;
use Cwd;

# Read in input...
my $refname = shift;
my $oldsha1 = shift;
my $newsha1 = shift;

# Read needed environment variables
$git_dir = $ENV{'GIT_DIR'};
$push_user = $ENV{'GL_USER'};
$user_home = $ENV{'HOME'};

# Ensure the information is fully usable
if( $git_dir eq "." ) {
    $git_dir = getcwd();
}

# Verify the provided information is valid....
if( $refname eq "" || $oldsha1 eq "" || $newsha1 eq "" || $git_dir eq "" || $push_user eq "" ) {
    print "Information needed to run could not be gathered successfully.\n";
    print "Required environment variables: GIT_DIR, GL_USER, HOME\n";
    print "Syntax: update.secondary <refname> <oldsha> <newsha>\n";
    exit 1;
}

###############
### Initialisation Phase
###############

# Ensure that git.kde.org services have not been globally suspended (or suspended for this repo)
if( -e "$user_home/.gitolite.down" || -e "$git_dir/.gitolite.down" ) {
    print "Sorry, but the repository you are trying to access is currently unavailable.\n";
    print "This is to allow for maintenance, we apologise for any inconvience caused.\n";
    print "If you believe this not to be the case, please contact sysadmin\@kde.org.\n";
    exit 1;
}

# Retrieve some information about the repositories...
my $repoid = repository_id( $git_dir );
my $repopath = repository_path( $git_dir );

# Generate the information that gitweb will later use...
unless( -e "$git_dir/cloneurl" ) {
    open(CLONEURLS, ">$git_dir/cloneurl");
    print CLONEURLS "Pull (read-only): git://anongit.kde.org/$repopath\n";
    print CLONEURLS "Pull (read-only): http://anongit.kde.org/$repopath\n";
    print CLONEURLS "Pull+Push (read+write): git\@git.kde.org:$repopath\n";
    close(CLONEURLS);
}

###############
### Information collection phase
###############

# Retrieve some information....
my $repo_type = repository_type( $repopath );
my $ref_change = object_change( $oldsha1, $newsha1 );
my ( $ref_type, $ref_subname ) = object_details( $refname );

# Get a list of revisions which are going to change....
@new_revisions = revision_list( $oldsha1, $newsha1, $ref_change );

# Prepare a count of revisions for later use if needed....
$revision_count = @revision_list;

###############
### Auditing Phase
###############

# Check the operation they are trying to perform on the refs...
if( $ref_type eq REF_BACKUP ) {
    # Caught trying to tamper with a backup eh?
    print "ATTEMPTED BACKUP TAMPER DETECTED!\n";
    print "PUSH DECLINED - POLICY VIOLATION!\n";
    exit 1;
} elsif( $ref_type eq REF_UNKNOWN ) {
    print "Sorry, but the ref you are trying to push to could not be recognised.\n";
    print "Only pushes to branches and tags are supported.\n";
    exit 1;
}

# Prepare to audit inbound commits....
my $auditcfg = "$repomgmt_dir/repo-configs/audit/${repopath}.git";
my @filenamecfg = audit_load_filename_cfg( $repomgmt_dir );
my $auditerror = 0;

# Audit the incoming commits
foreach my $commit( @new_revisions ) {
    # Do we have a per-user exception?
    next if $push_user =~ m/scripty/;

    # Initialise...
    my @errors;

    # Invoke the audits on the given commit if needed...
    audit_diff( $commit, \@errors ) unless -e "$auditcfg/skip-eol";
    audit_filenames( $commit, \@errors, \@filenamecfg ) unless -e "$auditcfg/skip-filename";
    audit_metadata( $commit, \@errors ) unless -e "$auditcfg/skip-author";

    # Don't try to show errors if we have none....
    my $error_count = @errors;
    next if $error_count == 0;

    # Ok, we got errors, output them
    print "** Audit Failure - commit $commit **\n";
    foreach my $errmsg( @errors ) {
        print "   $errmsg\n";
    }
    $auditerror = 1;
}

# If Audit rejected it, then we bail out
if( $auditerror == 1 ) {
    exit 1;
}

###############
### Pre-Acceptance Phase
###############

# Do we need to backup the ref being pushed?
if( $ref_change eq CHANGE_FORCED || $ref_change eq CHANGE_DELETE ) {
    # Back it up!
    my $timestamp = time();
    read_git( 'update-ref', "refs/backup/$ref_type-$ref_subname-$timestamp", $oldsha1 );
}

# Are post-commit hooks disabled on this repository?
if( -e "$git_dir/kde-hooks-off" ) {
    # Perform Gitolite access control check....
    $repo_admin = 0;
    if( !$repo_admin ) {
        print "Repository access DENIED by Sysadmin Policy";
        print "Repository post commit hooks are currently disabled";
        print "Please contact sysadmin\@kde.org for further assistance";
        exit 1;
    }

    print "***** NOTICE *****";
    print "** Post commit hooks are DISABLED";
    print "** Push access is restricted to repository admins";
    print "***** NOTICE *****";
    exit 0
}

###############
### Post-Acceptance Phase
###############

# Lets output a convenient access url... exclude sysadmin repos though -> non-public
if( $repo_type ne REPO_SYSADMIN ) {
    if( $revision_count == 1 ) {
        print "In a few minutes this commit will be available for viewing at:\n";
    } else {
        print "In a few minutes the last commit in the series will be available for viewing at:\n";
    }
    print "http://commits.kde.org/$repoid/$newsha1\n";
}

exit 1;

# Returns a list of revisions for the given oldsha1 and newsha1, which are new to this repository
# This is mainly seperated out as it is quite large. Arguments: oldsha1 newsha1 ref_change_type
sub revision_list
{
    my $oldsha1 = shift;
    my $newsha1 = shift;
    my $ref_change = shift;

    # Build the revision span git will use to help build the revision list...
    if( $ref_change eq CHANGE_CREATE ) {
       $revision_span = "$newsha1";
    } else {
       $revision_span = read_git_oneline( 'merge-base', $newsha1, $oldsha1 ) . "..$newsha1";
    }

    # Get a list of objects which are not in any of our refs....
    @step1 = read_git( 'rev-parse', '--not', '--all' );
    # Exclude the old item in case it crept in...
    @step2 = grep( !/$oldsha1/, @step1 );
    return read_git( 'rev-list', '--reverse', $revision_span, @step2 );
}

# Creates the repository uid if needed, and reads the nick and returns that instead of the uid if it is available.
# Arguments: path to the repository of which to generate the id of...
sub repository_id
{
    # Generate the repository id....
    my $repository = shift;
    my $repoid = `echo $repository | sha1sum | cut -c -8`;

    # Write out the repository uid if it doesn't exist
    unless( -e "$git_dir/kde-repo-uid" ) {
        open(REPOUID, ">$repository/kde-repo-uid");
        print REPOUID $repoid;
        close(REPOUID);
    }

    # Check to see if we have a repository nick, and use that instead of it's uid...
    if( -e "$repository/kde-repo-nick" ) {
        return read_file( "$repository/kde-repo-nick" );
    }

    # Return the default repository id
    return read_file( "$repository/kde-repo-uid" );
}

# Extracts the externally visible repository path, excluding the ".git" suffix.
# WARNING: Causes the script to exit immediately if the extraction failed.
sub repository_path
{
    # A few things...
    my $fspath = shift;

    if( $fspath =~ s,^/home/ben/sysadmin/(.+).git$,, ) {
        return $1;
    }

    die "Error - Failed to extract repository path from $fspath\n";
}

# Determines the type of repository (whether sysadmin, website, scratch, clone or normal)
# Returns the repository type through a REPO_* constant
sub repository_type
{
    my $repopath = shift;

    # What type of repo have we got???
    if( $repopath =~ s,sysadmin/(.+)$,, || $repopath eq "gitolite-admin" ) {
        return REPO_SYSADMIN;
    } elsif( $repopath =~ s,websites/(.+)$,, ) {
        return REPO_WEBSITE;
    } elsif( $repopath =~ s,scratch/(.+)$,, ) {
        return REPO_SCRATCH;
    } elsif( $repopath =~ s,clones/(.+)$,, ) {
        return REPO_CLONE;
    }

    return REPO_NORMAL;
}

# Retrieves some information about the ref being changed. Namely, it's type and the name of the object itself
# Returns an array, of the type and the name
# Example: ( "tag", "v1.0.0" )
sub object_details
{
    # Initialisation....
    my $refname = shift;

    # What type is the ref being changed?
    if( $refname =~ s,refs/heads/(.+)$,, ) {
        return( REF_BRANCH, $1 );
    } elsif( $refname =~ s,/^refs/tags/(.+)$,, ) {
        return( REF_TAG, $1 );
    } elsif( $refname =~ s,/^refs/backups/(.+)$/,, ) {
        return( REF_BACKUP, $1 );
    }

    return( REF_UNKNOWN, "" );
}

# Determines the type of change being done to a ref, based on it's old revision and new revision
# Returns the type of change as a CHANGE_* constant
sub object_change
{
    # Initialisation...
    my $oldsha1 = shift;
    my $newsha1 = shift;
    my $ref_merge_base = "";

    # Determine the merge base, to detect if we are experiencing a force or normal push....
    if( $oldsha1 ne GIT_EMPTY_REF && $newsha1 ne GIT_EMPTY_REF ) {
        $ref_merge_base = read_git_oneline('merge-base', $oldsha1, $newsha1);
    }

    # What type of change is happening here?
    if( GIT_EMPTY_REF eq $oldsha1  ) {
        return CHANGE_CREATE;
    } elsif( GIT_EMPTY_REF eq $newsha1 ) {
        return CHANGE_DELETE;
    } elsif( $ref_merge_base ne $oldsha1 ) {
        return CHANGE_FORCED;
    }

    return CHANGE_UPDATE;
}

# Reads the first line of a file in....
sub read_file
{
    my $filename = shift;

    open(INPUTFILE, "<$filename"); # open for input
    my @lines = <INPUTFILE>; # read file into list
    close(INPUTFILE);

    my $data = shift(@lines);
    chomp($data);
    return $data;
}
